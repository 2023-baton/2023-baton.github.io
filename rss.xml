<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of baton]]></title><description><![CDATA[우아한테크코스 5기 바톤팀의 기술 블로그입니다.]]></description><link>https://2023-baton.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 31 Jul 2023 08:13:31 GMT</lastBuildDate><item><title><![CDATA[지속적 배포(CD)를 GitHub Self Hosted Runner와 Docker Hub로 해보자]]></title><description><![CDATA[💬 개요 먼저 지속적 배포(CD, Continuous Deploy)를 구축하기 위해서 다음과 같은 기술을 선택했습니다. GitHub Self Hosted Runner : 현재 클라우드 상황에 적합하다. Docker Hub : EC…]]></description><link>https://2023-baton.github.io/02.GitHub_Self_Hosted_Runner_Docker_Hub를_이용한_지속적_배포/</link><guid isPermaLink="false">https://2023-baton.github.io/02.GitHub_Self_Hosted_Runner_Docker_Hub를_이용한_지속적_배포/</guid><pubDate>Mon, 31 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;💬 개요&lt;/h2&gt;
&lt;p&gt;먼저 지속적 배포(CD, Continuous Deploy)를 구축하기 위해서 다음과 같은 기술을 선택했습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Self Hosted Runner : 현재 클라우드 상황에 적합하다.&lt;/li&gt;
&lt;li&gt;Docker Hub : EC2 내부에서 스프링 프로젝트가 빌드(build)된 이미지(Image)를 가져와 실행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/ae049740-d32f-4aac-9d4d-8c20ba042e11&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;&lt;strong&gt;✅ GitHub Self Hosted Runner&lt;/strong&gt;를 선택한 이유&lt;/h2&gt;
&lt;p&gt;현재 진행하고 있는 프로젝트의 클라우드 환경에 가장 적합하다고 느꼈다.&lt;/p&gt;
&lt;p&gt;사용하고 있는 EC2의 vpc 환경은 외부에서 내부로 들어올 수 있는 ip와 port가 제한된 상태였다.&lt;/p&gt;
&lt;p&gt;때문에 GitHub Actions의 워크플로우(workflow)를 이용하여 scp 명령어로 빌드된 jar를 전송하거나 AWS에 접근해서 스크립트를 직접 실행하는 것이 불가능했다.&lt;/p&gt;
&lt;p&gt;즉, EC2 내부에서 지속적 배포를 진행하기 위해서는 EC2 내부에서 외부로 접근하는 방식이 필요했다.&lt;/p&gt;
&lt;p&gt;이 때 사용해본 경험이 있는 도구는 두 가지였는데&lt;/p&gt;
&lt;p&gt;바로 Jenkins와 GitHub Self Hosted Runner 였고 나는 후자인 GitHub를 선택했다.&lt;/p&gt;
&lt;p&gt;Jenkins에 비해 러닝 커브가 적고 GitHub와 연동이 잘되어 있어 문제 해결이 쉽기 때문이다.&lt;/p&gt;
&lt;p&gt;Jenkins가 필요한 자원보다 GitHub Self Hosted Runner가 더 적다는 장점을 가지고 있다.&lt;/p&gt;
&lt;p&gt;또한 같은 프로젝트를 진행하고 있는 팀원들에게 GitHub를 설명하여 기술을 전파하는 것이 Jenkins 보다 더 쉽다는 것도 선택한 이유 중 하나다.&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;&lt;strong&gt;✅ 🐳 Docker Hub&lt;/strong&gt;를 선택한 이유&lt;/h2&gt;
&lt;p&gt;AWS에서 EC2를 띄어 사용하고 있는 상태에서 스프링 프로젝트를 클론 받아 빌드하는 경우 EC2 메모리가 부족해질 수도 있다.&lt;/p&gt;
&lt;p&gt;이러한 위험성을 줄이기 위해서 미리 빌드된 jar 파일을 가져와서 실행시키도록 했다.&lt;/p&gt;
&lt;p&gt;하지만 현재 클라우드 환경은 빌드된 jar를 바로 가져올 수 없다.&lt;/p&gt;
&lt;p&gt;AWS에서 제공하는 S3와 같은 기술을 사용하지 않고 jar 파일을 다운받아 실행시켜야 했다.&lt;/p&gt;
&lt;p&gt;또한 저희는 하나의 EC2에서 React, Nginx, Spring을 같이 띄워 놓을거기 때문에 이후에 꼬이는 것을 방지하기 위해 환경을 독립적으로 가져갈 수 있었으면 했다.&lt;/p&gt;
&lt;p&gt;이러한 상황을 봤을 때 컨테이너로 환경을 제공해주면서 빌드된 이미지(image)를 풀(pull)받아 서버를 실행시킬 수 있는 도커(🐳 Docker)를 선택하기로 했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;기술이 정해졌고 대략적인 플로우도 나왔다.&lt;br&gt;
🤔 그렇다면 이제 무슨 일을 해야 할까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이론적으로 현재 플로우에 대해 이해는 할 수 있었지만 실제로 기술을 사용해본적은 없기 때문에 먼저 기존 플로우를 다시 한 번 정리하면서 해야할 일을 체크리스트로 만들었다.&lt;/p&gt;
&lt;p&gt;💬 먼저 플로우를 정리해보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Repository의 브랜치에 push 되었을 때 GitHub가 인지하고 스프링 프로젝트를 빌드(build)한다.&lt;/li&gt;
&lt;li&gt;빌드된 jar파일을 도커 이미지(Docker Image)로 만들어 도커 허브(Docker Hub)에 push한다.&lt;/li&gt;
&lt;li&gt;EC2에 띄운 GitHub Self Hosted Runner가 도커 허브가 업데이트 되었다는 것을 확인하고 도커 이미지를 자동으로 pull한다.&lt;/li&gt;
&lt;li&gt;EC2에 있는 도커 이미지를 컨테이너로 띄워 스프링 서버를 실행시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;플로우를 작성하고 흐름은 이해 되었다. 이제 체크리스트를 작성하면서 구체화 시켜보자.&lt;/p&gt;
&lt;p&gt;✔️ 체크리스트&lt;/p&gt;
&lt;p&gt;- 깃허브가 제공하는 클라우드 환경에서 할 일&lt;/p&gt;
&lt;p&gt;  - GitHub Repository 클론&lt;/p&gt;
&lt;p&gt;  - JDK 17 환경 설정&lt;/p&gt;
&lt;p&gt;  - Gradle Build&lt;/p&gt;
&lt;p&gt;  - Docker Buildx&lt;/p&gt;
&lt;p&gt;  - Docker Login&lt;/p&gt;
&lt;p&gt;  - Docker Image Build&lt;/p&gt;
&lt;p&gt;  - Docker Hub Push&lt;/p&gt;
&lt;p&gt;- EC2 내부에 있는 GitHub Self Hosted Runner가 할 일 &lt;/p&gt;
&lt;p&gt;  - Docker Login&lt;/p&gt;
&lt;p&gt;  - Docker Pull&lt;/p&gt;
&lt;p&gt;  - Docker Run&lt;/p&gt;
&lt;p&gt;이제 이 흐름을 따라가보자.&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;🟩 깃허브가 제공하는 클라우드 환경에서 할 일&lt;/h2&gt;
&lt;p&gt;먼저 &apos;&lt;strong&gt;깃허브가 제공하는 클라우드 환경에서 할 일&lt;/strong&gt;&apos;을 끝내보자.&lt;/p&gt;
&lt;h3&gt;01. on: push : branches: [&quot;dev/BE&quot;]&lt;/h3&gt;
&lt;p&gt;workflow를 트리거(trigger)하기 위해서는 이벤트(event)를 발생시켜야 한다.&lt;/p&gt;
&lt;p&gt;현재 &apos;dev/BE&apos; 브랜치에 push 이벤트가 발생했을 때 workflow가 동작해야 한다.&lt;/p&gt;
&lt;p&gt;깃허브에서는 이러한 push 이벤트가 발생했을 때 workflow가 트리거할 수 있도록 설정하는 명령어를 문서에 정리해두었다.&lt;/p&gt;
&lt;p&gt;사용자 입장에서는 workflow에 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;on:
  push:
    branches: [ &quot;dev/BE&quot; ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/ko/actions/using-workflows/events-that-trigger-workflows#push&quot;&gt;워크플로를 트리거하는 이벤트 - GitHub Docs&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;02. jobs: build: runs-on: ubuntu-latest&lt;/h3&gt;
&lt;p&gt;workflow를 실행할 수 있는 환경을 러너(runner)라고 한다.&lt;/p&gt;
&lt;p&gt;그리고 workflow 내부에 작업(job)들을 진행하기 위해서는 운영체제와 같은 환경을 만들어줘야 한다.&lt;/p&gt;
&lt;p&gt;MacOS, Window 환경에서 작업을 진행할 수 있지만 EC2가 Linux로 띄어져있기 때문에 Ubuntu를 이용하기로 한다.&lt;/p&gt;
&lt;p&gt;workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;jobs:
  build:
    runs-on: ubuntu-latest&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/ko/actions/using-github-hosted-runners/about-github-hosted-runners&quot;&gt;GitHub 호스팅 실행기 정보 - GitHub Docs&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;03. uses: actions/checkout&lt;/h3&gt;
&lt;p&gt;GitHub Actions를 사용해서 스프링 프로젝트를 빌드하려면 먼저 기본적인 파일을 클론받아야 한다.&lt;/p&gt;
&lt;p&gt;이 스텝을 하나의 액션(Action)으로 GitHub Marketplace에서 제공하고 있다.&lt;/p&gt;
&lt;p&gt;workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;on:
  push:
    branches: [ &quot;dev/BE&quot; ]

jobs:
  build:
    runs-on: ubuntu-latest


# 위에 적힌 내용은 depth를 보여주기 위해 따로 분리하지 않았다.
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/marketplace/actions/checkout&quot;&gt;Checkout - GitHub Marketplace&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;04. uses: actions/setup-java&lt;/h3&gt;
&lt;p&gt;JDK 17를 사용하고 있는 스프링 프로젝트를 빌드하기 위해서 JDK를 설치하는 액션을 사용한다.&lt;/p&gt;
&lt;p&gt;workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: &apos;17&apos;
          distribution: &apos;corretto&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/marketplace/actions/setup-java-jdk&quot;&gt;Setup Java JDK - GitHub Marketplace&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;05. uses: gradle/gradle-build-action&lt;/h3&gt;
&lt;p&gt;Gradle로 스프링 프로젝트를 관리하고 있다. Gradle을 통해서 프로젝트를 빌드하려고 한다.&lt;/p&gt;
&lt;p&gt; workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;      - name: Build with Gradle
        uses: gradle/gradle-build-action@v2.6.0
      - name: Execute Gradle build
        run: |
          cd backend/baton
          ./gradlew build&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/marketplace/actions/gradle-build-action&quot;&gt;Gradle Build Action - GitHub Marketplace&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;06. uses: docker/login-action&lt;/h3&gt;
&lt;p&gt;Docker Hub에 만든 이미지를 푸쉬하기 위해서 계정으로 로그인한다.&lt;/p&gt;
&lt;p&gt;Docker에 로그인하고 계정에서 토큰을 만들어야 접근이 가능하다.&lt;/p&gt;
&lt;p&gt;아래는 아직 토큰을 만들지 않은 상태의 페이지다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/b5684ce0-98a7-4a58-af17-8f7829338707&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;토큰을 만들어서 GitHub Secret에 등록해서 workflow에서 사용하도록 설정했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/42caa09a-f2b3-4e0d-b778-b760d999555d&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;참고로  workflow에서 secret을 사용하기 위해서는 `${{ secrets.이름 }}`와 같은 형식으로 작성하면 된다.&lt;/p&gt;
&lt;p&gt;workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;      - name: Login to Docker Hub
        uses: docker/login-action@v2.2.0
        with:
          username: ${{ secrets.DOCKERHUB_DEV_USERNAME }}
          password: ${{ secrets.DOCKERHUB_DEV_TOKEN }}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub Container Image Library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/marketplace/actions/docker-login&quot;&gt;Docker Login - GitHub Marketplace&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3&gt;07. run: docker build&lt;/h3&gt;
&lt;p&gt;Docker Image를 만들기 위해서 docker build 명령어를 작성한다.&lt;/p&gt;
&lt;p&gt;프로젝트 최상단 패키지에 만들어 놓은 Dockerfile을 실행할 수 있도록 명시했다.&lt;/p&gt;
&lt;p&gt;Dockerfile 내용은 다음과 같다.&lt;br&gt;
EC2 환경은 arm64v8이다.&lt;/p&gt;
&lt;p&gt;JDK는 Corretto 17을 이용했다.&lt;/p&gt;
&lt;p&gt;jar를 복사고 스프링 프로필 환경 변수를 dev로 두고 스프링 서버를 실행시킨다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;FROM arm64v8/amazoncorretto:17

WORKDIR /app

COPY ./build/libs/baton-0.0.1-SNAPSHOT.jar /app/baton.jar

CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;-Dspring.profiles.active=dev&quot;, &quot;baton.jar&quot;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;      - name: Docker Image Build
        run: |
          cd backend/baton
          docker build --platform linux/arm64/v8 -t 2023baton/2023baton -f Dockerfile-dev .&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;08. run: docker push&lt;/h3&gt;
&lt;p&gt;이제 이미지로 만든 스프링 프로젝트를 Docker Hub에 push하자.&lt;/p&gt;
&lt;p&gt;먼저 Docker에서 Repository를 만들자.&lt;/p&gt;
&lt;p&gt;workflow에 `docker push 2023baton/2023baton` 이라는 명령어가 명시되어 있는데&lt;/p&gt;
&lt;p&gt;`docker push {docker_username}/{docker_repository_name}` 형태로 명시하면 된다.&lt;/p&gt;
&lt;p&gt;workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;      - name: Docker Hub Push
        run: docker push 2023baton/2023baton&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;09. `&lt;strong&gt;깃허브가 제공하는 클라우드 환경에서 할 일`&lt;/strong&gt; workflow 종합&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/5140c7d1-362d-4ac7-a106-abd3dc646f65&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;01 ~ 08 까지 소개한 스텝들을 합쳐 하나의 워크플로우를 작성하면 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;on:
  push:
    branches: [ &quot;dev/BE&quot; ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: &apos;17&apos;
          distribution: &apos;corretto&apos;

      - name: Build with Gradle
        uses: gradle/gradle-build-action@v2.6.0
      - name: Execute Gradle build
        run: |
          cd backend/baton
          ./gradlew build

      - name: Login to Docker Hub
        uses: docker/login-action@v2.2.0
        with:
          username: ${{ secrets.DOCKERHUB_DEV_USERNAME }}
          password: ${{ secrets.DOCKERHUB_DEV_TOKEN }}

      - name: Docker Image Build
        run: |
          cd backend/baton
          docker build --platform linux/arm64/v8 -t 2023baton/2023baton -f Dockerfile-dev .

      - name: Docker Hub Push
        run: docker push 2023baton/2023baton&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;🟩 EC2 내부에 있는 GitHub Self Hosted Runner가 할 일&lt;/h2&gt;
&lt;p&gt;이제 Docker Hub에 스프링 이미지까지 올라가 있다.&lt;/p&gt;
&lt;p&gt;EC2에 있는 GitHub Self Hosted Runner가 Docker Hub에 이미지를 pull해서 컨테이너를 실행하도록 workflow를 작성하자.&lt;/p&gt;
&lt;h3&gt;01. GitHub Self Hosted Runner 설치&lt;/h3&gt;
&lt;p&gt;Repository의 Settinggs에 들어가 Actions 탭에 Runners를 들어가서 `New self-hosted runner` 버튼을 누르면 명령어를 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/d29a74d2-cd05-482d-9570-8daff8d0e414&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;다음과 같이 Runner Image를 고를 수 있고 다운로드, 설정, 실행 등 의 정보를 전부 제공해주기 때문에 EC2에 명령어를 실행하면 끝이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/9f8cdb9e-0b19-4027-bf66-4ee4350e3bd9&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h3&gt;02. runs-on: [self-hosted]&lt;/h3&gt;
&lt;p&gt;EC2에 GitHub Self Hosted Runner를 설치했다면 workflow를 작성해주자.&lt;/p&gt;
&lt;p&gt;`self-hosted`라고 작성하면 우리가 방금 만든 runner를 선택하게 된다.&lt;/p&gt;
&lt;p&gt;만약 다음과 같이 Self-Hosted Runner가 두 개 이상이라면 라벨(label)을 넣어서 구분할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/d18331d0-15bf-4b3c-ac19-817065076ac7&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;다음과 같은 상황에서 나는 deploy 환경에서는 deploy라는 라벨을 붙였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/b5340890-b187-44d1-bc0a-c9a86e08e93b&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;runner가 1개 일 때는 workflow는 다음과 같이 작성할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;jobs:
  dev-deploy:
    runs-on: self-hosted&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;runner가 2개 이상일 때는 구분지을 수 있어야 되기 때문에 아래와 같이 라벨까지 명시해주면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# Self-Hosted Runner : dev
jobs:
  dev-deploy:
    runs-on: [self-hosted, Linux, ARM64]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;# Self-Hosted Runner : deploy 
jobs:
  dev-deploy:
    runs-on: [self-hosted, Linux, ARM64, deploy]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;현재 워크플로우에서 사용하는 Self-Hosted Runner는 dev라는 것을 생각해줬으면 좋겠다.&lt;/p&gt;
&lt;h3&gt;03. needs: build&lt;/h3&gt;
&lt;p&gt;이전에 Docker Hub에 이미지를 push하는 작업이 있었다.&lt;/p&gt;
&lt;p&gt;그리고 지금 작성하고 있는 작업은 EC2에서 Docker Hub 이미지를 pull 받아 컨테이너를 실행시키는 것이다.&lt;/p&gt;
&lt;p&gt;이 때 순서를 정해주지 않으면 업데이트 되지 않은 이미지를 받아 컨테이너를 실행시킬 수 도 있다.&lt;/p&gt;
&lt;p&gt;그러한 문제를 해결하기 위해서 needs라는 키워드를 달아 build라는 작업이 끝나면 다음 작업이 진행되도록 만들자.&lt;/p&gt;
&lt;p&gt;workflow에는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;on:
  push:
    branches: [ &quot;dev/BE&quot; ]

jobs:
  build:
    runs-on: ubuntu-latest

  deploy:
    runs-on: [self-hosted, Linux, ARM64]
    needs: build&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;04. docker pull&lt;/h3&gt;
&lt;p&gt;이제 Docker Hub에 로그인하여 이미지를 pull하도록 하자.&lt;/p&gt;
&lt;p&gt;Docker Hub에 2023baton 레포지터리에서 2023baton 이미지를  pull한다.&lt;/p&gt;
&lt;p&gt;workflow는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    steps:
      - name: Pull Latest Docker Image
        run: |
          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}
          sudo docker pull 2023baton/2023baton:latest&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;05. docker run&lt;/h3&gt;
&lt;p&gt;Docker Image가 pull 받아 최신 상태가 된 경우 스프링 Container를 멈추고 삭제한다.&lt;/p&gt;
&lt;p&gt;그리고 다시 새로운 Container를 띄우도록 한다.&lt;/p&gt;
&lt;p&gt;workflow는 다음과 같이 작성하면 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    steps:
      - name: Pull Latest Docker Image
        run: |
          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}
          if sudo docker inspect spring-baton &amp;amp;&gt;/dev/null; then
            sudo docker stop spring-baton
            sudo docker rm -f spring-baton
          fi
          sudo docker pull 2023baton/2023baton:latest

      - name: Docker Run
        run: |
          sudo docker run --name spring-baton -p 8080:8080 2023baton/2023baton:latest 1&gt;&gt; build.log 2&gt;&gt; error.log &amp;amp;name: dev/BE CD on Push&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;06. `&lt;strong&gt;EC2 내부에 있는 GitHub Self Hosted Runner가 할 일&lt;/strong&gt;` worflow 종합&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/2023-baton/2023-baton.github.io/assets/82203978/675fcde0-5e8e-4bab-aca5-d47a262329f4&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;  deploy:
    runs-on: [self-hosted, Linux, ARM64]
    needs: build

    steps:
      - name: Pull Latest Docker Image
        run: |
          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}
          if sudo docker inspect spring-baton &amp;amp;&gt;/dev/null; then
            sudo docker stop spring-baton
            sudo docker rm -f spring-baton
          fi
          sudo docker pull 2023baton/2023baton:latest

      - name: Docker Run
        run: |
          sudo docker run --name spring-baton -p 8080:8080 2023baton/2023baton:latest 1&gt;&gt; build.log 2&gt;&gt; error.log &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;🟩 최종 워크플로우&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;name: dev/BE CD on Push

on:
  push:
    branches: [ &quot;dev/BE&quot; ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.SUBMODULE_BE_TOKEN }}
          submodules: recursive

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: &apos;17&apos;
          distribution: &apos;corretto&apos;

      - name: Build with Gradle
        uses: gradle/gradle-build-action@v2.6.0
      - name: Execute Gradle build
        run: |
          cd backend/baton
          ./gradlew build

      - name: Login to Docker Hub
        uses: docker/login-action@v2.2.0
        with:
          username: ${{ secrets.DOCKERHUB_DEV_USERNAME }}
          password: ${{ secrets.DOCKERHUB_DEV_TOKEN }}

      - name: Docker Image Build
        run: |
          cd backend/baton
          docker build --platform linux/arm64/v8 -t 2023baton/2023baton -f Dockerfile-dev .

      - name: Docker Hub Push
        run: docker push 2023baton/2023baton

  deploy:
    runs-on: [self-hosted, Linux, ARM64]
    needs: build

    steps:
      - name: Pull Latest Docker Image
        run: |
          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}
          if sudo docker inspect spring-baton &amp;amp;&gt;/dev/null; then
            sudo docker stop spring-baton
            sudo docker rm -f spring-baton
          fi
          sudo docker pull 2023baton/2023baton:latest

      - name: Docker Compose
        run: |
          sudo docker run --name spring-baton -p 8080:8080 2023baton/2023baton:latest 1&gt;&gt; build.log 2&gt;&gt; error.log &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이제 브랜치에 push 할 때 마다 새로운 이미지가 Docker Hub에 push 되고 Self-hosted는 pull 받아 새로운 컨테이너를 띄운다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[🐳 도커로 DB 관리하기]]></title><description><![CDATA[안녕하세요 이번에 바톤 프로젝트를 기초 세팅하는 시간을 가졌는데요. 그 중 docker로 DB를 관리하는 부분이 기억에 남아 글로 기록해보려합니다. docker로 DB를 관리하게 된 이유…]]></description><link>https://2023-baton.github.io/first/</link><guid isPermaLink="false">https://2023-baton.github.io/first/</guid><pubDate>Thu, 20 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;안녕하세요 이번에 바톤 프로젝트를 기초 세팅하는 시간을 가졌는데요. 그 중 docker로 DB를 관리하는 부분이 기억에 남아 글로 기록해보려합니다.&lt;/p&gt;
&lt;h2&gt;docker로 DB를 관리하게 된 이유&lt;/h2&gt;
&lt;h3&gt;1. 일관된 환경&lt;/h3&gt;
&lt;p&gt;도커 이미지를 사용하면 개발, 로컬, 운영 환경에서 모두 동일한 이미지를 배포할 수 있습니다.
즉, 모든 데이터베이스의 환경을 동일하게 유지할 수 있고 환경 변화가 있다면 동일하게 환경을 변경시킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한 도커 컴포즈를 이용하여 로컬에서도 동료들간 같은 환경을 구성하여 DB를 사용할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;2. 환경 충돌 방지&lt;/h3&gt;
&lt;p&gt;우아한테크코스에서 DB를 위한 ec2 인스턴스는 1개만 제공되었습니다.
나중에 mysql 뿐만 아니라 다른 db를 추가하게 되는 경우에 인스턴스 내부에서 환경이 얽힐수도 있겠다는 생각을 했습니다.
만약 도커를 이용하여 컨테이너를 분리하게 된다면 환경이 얽힐 일이 없고, 더 안정적인 운영이 가능하다고 생각했습니다.&lt;/p&gt;
&lt;h3&gt;3. 손쉬운 스케일링&lt;/h3&gt;
&lt;p&gt;서비스가 커지게되면 트래픽이 늘어나고 부하가 발생할 수 있는데요.
이때 도커를 이용하면 컨테이너를 필요한 시점에 빠르게 확장하거나 축소할 수 있습니다.&lt;/p&gt;
&lt;/br&gt;
&lt;h2&gt;EC2에 도커 설치&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; snap &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;명령어를 이용하여 도커를 설치합니다.&lt;/p&gt;
&lt;p&gt;처음에는 &lt;code class=&quot;language-text&quot;&gt;apt update&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;apt install&lt;/code&gt; 명령어를 통해 도커를 설치하려 했는데, 잘 되지 않았습니다.
찾아보니 요즘은 &lt;code class=&quot;language-text&quot;&gt;snap&lt;/code&gt;을 사용하면 더 간단히 도커를 설치할 수 있기에 &lt;code class=&quot;language-text&quot;&gt;snap&lt;/code&gt; 사용을 권장한다고 하네요.
&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/25198967-049d-4723-9a59-c0b4ca7e5857/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 설치를 완료했습니다.
&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/6dcd0c64-4f45-491f-b172-b850c0a0febb/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;저는 매번 &lt;code class=&quot;language-text&quot;&gt;sudo&lt;/code&gt;를 이용하여 권한 인증하는 것이 귀찮아서 추가적인 설정을 통해 일반 사용자도 도커에 접근할 수 있도록 설정했습니다.
과정은 &lt;a href=&quot;https://snapcraft.io/docker&quot;&gt;해당 링크&lt;/a&gt;를 참고했습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt; &lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; addgroup &lt;span class=&quot;token parameter variable&quot;&gt;--system&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt;
 &lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; adduser &lt;span class=&quot;token environment constant&quot;&gt;$USER&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt;
 newgrp &lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt;
 &lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; snap disable &lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt;
 &lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; snap &lt;span class=&quot;token builtin class-name&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;before&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/103f8395-0ee3-4eb8-935d-5fc165ae413c/image.png&quot;&gt;&lt;/p&gt;
&lt;h3&gt;after&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/f1634b4b-120e-4808-943c-34a901dedf99/image.png&quot;&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h2&gt;도커에 mysql 컨테이너 설치&lt;/h2&gt;
&lt;h3&gt;이미지 다운&lt;/h3&gt;
&lt;p&gt;도커에서 mysql 이미지를 다운받습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt; pull mysql&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;도커에서 &lt;strong&gt;이미지&lt;/strong&gt;란 하나의 환경파일(?)을 말합니다. nginx, mysql, node 등등 많은 이미지들이 있는데, 사용 목적에 맞게 이미지를 선택해서 컨테이너로 생성하면 해당 이미지에 맞는 환경이 설치된 상태로 컨테이너를 사용할 수 있습니다.
OOP에서 원하는 클래스의 인스턴스를 생성하는 것과 비슷한 느낌이라고 할 수 있겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/9994784b-ed69-470b-8d09-e0323d42bc15/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;mysql 이미지가 정상적으로 깔린 것을 확인할 수 있습니다.
&lt;code class=&quot;language-text&quot;&gt;tag&lt;/code&gt;는 버전을 뜻하는데, latest는 가장 최신버전이라는 뜻입니다. 만약 제가 &lt;code class=&quot;language-text&quot;&gt;docker pull mysql:8.0.33&lt;/code&gt; 명령어로 이미지를 풀 받게 되면 해당 버전의 mysql을 풀 받습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/1dae895b-e8e4-48f4-88b1-19527ffb205e/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;현재 가장 최근 버전의 mysql이 8.0.33 이어서 image id가 같은 것 같습니다.&lt;/p&gt;
&lt;h3&gt;컨테이너 생성 &amp;#x26; 실행&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt; run &lt;span class=&quot;token parameter variable&quot;&gt;--name&lt;/span&gt; mysql-dev-container &lt;span class=&quot;token parameter variable&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;비밀번호&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3306&lt;/span&gt;:3306 mysql:latest&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;해석하자면, &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;--name&lt;/code&gt;: &lt;code class=&quot;language-text&quot;&gt;mysql-dev-container&lt;/code&gt;의 이름으로 컨테이너를 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;-e&lt;/code&gt;: 컨테이너의 환경 변수중 &lt;code class=&quot;language-text&quot;&gt;MYSQL_ROOT_PASSWORD&lt;/code&gt;를 입력한 비밀번호로 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;-d&lt;/code&gt;: 데몬 모드로 실행한다. (백그라운드 모드)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;-p&lt;/code&gt;: 호스트 포트:컨테이너 포트로 설정한다.&lt;/li&gt;
&lt;li&gt;이미지는 &lt;code class=&quot;language-text&quot;&gt;mysql:latest&lt;/code&gt; 로 설정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/f3d174f9-732d-49c7-befb-1bc570d1e138/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;정상적으로 컨테이너가 생긴 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;이제 컨테이너에 접속해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;token builtin class-name&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;token parameter variable&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;컨테이너 Id&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bash&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 명령어를 통해 도커 컨테이너 bash에 접속했습니다.&lt;/p&gt;
&lt;h3&gt;mysql에 db 생성&lt;/h3&gt;
&lt;p&gt;이제 컨테이너에 mysql database를 설치해보도록 하겠습니다.
여기부터는 일반 리눅스나 맥에서 database 생성하는 것과 똑같습니다.&lt;/p&gt;
&lt;p&gt;먼저 mysql에 접속합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;mysql &lt;span class=&quot;token parameter variable&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;token parameter variable&quot;&gt;-p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고, database를 생성합니다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;create database ditoo_dev&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;intellij에서 생성한 db에 정상적으로 접근되는지 확인해보겠습니다!
&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/92c5d4df-6651-44da-aa40-dea62909261e/image.png&quot;&gt;
정상적으로 접근되었습니다.&lt;/p&gt;
&lt;p&gt;간단한 post, tag, post_tag 테이블을 만들어 table이 정상적으로 생성되는지 확인해보도록 하겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/cb75119b-fa86-476b-9b26-bcf9001e992d/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;스프링 어플리케이션에서는 정상적으로 테이블이 생성된 것을 확인했습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/hooni_/post/19117d25-f71e-4d01-b1fb-65e754bf582a/image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;db에도 정상적으로 table이 생긴 것을 확인할 수 있었습니다.&lt;/p&gt;
&lt;/br&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;docker로 간단하게 db를 관리하는 것을 학습했습니다.
다음 시간에는 docker-compose를 이용하여 db, spring, react 모두 같이 관리하는 방법에 대해 학습해보려 합니다.&lt;/p&gt;</content:encoded></item></channel></rss>