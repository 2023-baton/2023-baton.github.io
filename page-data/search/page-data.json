{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"0. 들어가기 전에 바톤 프로젝트를 진행하면서 마주쳤던 컨테이너 간의 통신 문제를 재현해보고 해결 방법을 알아보겠습니다.  1. 문제 상황 바톤 프로젝트는 아래와 같이 백엔드 인프라 환경이 구성되어있습니다. image-20230729230650096 간단하게 설명하자면 깃허브에서 로의 push 이벤트가 발생하면 github actions로 빌드를 하고 빌…","fields":{"slug":"/03. 도커 컨테이너 간 통신 트러블 슈팅/"},"frontmatter":{"date":"August 03, 2023","title":"🔫 도커 컨테이너 간 통신 트러블 슈팅","tags":["docker","database","trouble shooting"]},"rawMarkdownBody":"\n<br/>\n\n## 0. 들어가기 전에\n\n바톤 프로젝트를 진행하면서 마주쳤던 컨테이너 간의 통신 문제를 재현해보고 해결 방법을 알아보겠습니다.\n\n<br/><br/>\n\n## 1. 문제 상황\n\n바톤 프로젝트는 아래와 같이 백엔드 인프라 환경이 구성되어있습니다.\n\n![image-20230729230650096](https://raw.githubusercontent.com/cookienc/typoraImg/image/img/image-20230729230650096.png)\n\n간단하게 설명하자면 깃허브에서 `dev/BE`로의 push 이벤트가 발생하면 github actions로 빌드를 하고 빌드된 파일을 이미지로 만들어 docker hub에 push 합니다. 그 후 `dev` EC2안에 있는 self hosted runner가 이미지가 업데이트된 것을 확인하고 이미지를 pull을 받아 자동으로 실행시켜 줍니다. deploy 환경에도 마찬가지입니다.\n\n이 중에서 문제가 발생했던 환경은 public subnet(dev) 입니다. 저희 백엔드에서는 환경 분리의 용이성 때문에 DB를 모두 도커안에 띄우기로 했는데요. 이 과정에서 SpringBoot가 아래와 같은 오류를 보내면서 DB를 찾을 수 없는 현상을 맞이하게 됩니다.\n\n![image-20230730185009180](https://raw.githubusercontent.com/cookienc/typoraImg/image/img/image-20230730185009180.png)\n\n<br/><br/>\n\n## 2. 문제 해결 과정\n\n기존 코드를 살펴보면 다음과 같습니다.\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/baton_dev\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: USERNAME\n    password: PASSWORD\n```\n\n데이터베이스를 찾지 못했기에 데이터베이스 관련 설정을 살펴봤습니다. 완벽한 설정 아닌가요?\n\nSpring Boot와 MySQL은 하나의 EC2 안에 같이 띄워져 있으니 `localhost`라고 설정을 해놨습니다. SSH 터널링을 이용해 접속했을 때 아무런 문제가 없었기에 되는 줄 알았습니다. 하지만 실패했습니다.\n\n이 방법은 아니라 생각하고 '컨테이너가 통신하려면 다른 방법이 있지 않을까?' 라는 생각을 떠올렸습니다. 그러다 생활코딩에서 들은 docker의 네트워크가 생각났습니다.\n\n도커의 네트워크는 같은 호스트의 두 개 이상의 컨테이너가 있을 때 컨테이너끼리 소통할 수 있게 하는 방법입니다.\n\n```bas\ndocker create network baton\ndocker network connect baton spring-baton\ndocker network connect baton mysql\n```\n\n위와 같은 방식으로 같은 baton이라는 네트워크를 만들어 컨테이너 간 연결을 해줬습니다.\n\n하지만 이 역시 실패를 했습니다.\n\n컨테이너에서 localhost는 컨테이너를 가리키는 의미한다는 걸 나중에 깨달았습니다.\n\n한 컨테이너 안에 spring과 mysql이 동시에 띄워진 상황이 아니라 소용이 없었던 것이었죠.\n\n그래서 저희는 네트워크 IP를 찾아봤습니다.\n\n```bash\ndocker inspect mysql\n```\n\nmysql 컨테이너를 조사해 연결된 네트워크(baton)을 찾아서 해당하는 컨테이너 IP 주소를 `application.yml`의 url에 입력해 줬습니다.\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://NETWORK_CONTAINER_IP:3306/baton_dev\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: USERNAME\n    password: PASSWORD\n```\n\n![image-20230730201149694](https://raw.githubusercontent.com/cookienc/typoraImg/image/img/image-20230730201149694.png)\n\n그 후 다행히도 애플리케이션을 정상적으로 실행시킬 수 있었습니다.\n\n그렇다면 컨테이너의 이름은 서로 unique하니 같은 네트워크로 연결되어 있으면 이름으로 구별해줄 수 있지 않을까? 라는 생각이 또 들었습니다.\n\n추가적으로 컨테이너 이름으로 설정파일을 변경하고 실행시켰더니 이 방법도 성공했습니다.\n\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://CONTAINER_NAME:3306/baton_dev\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    username: USERNAME\n    password: PASSWORD\n```\n\n\n\n<br/><br/>\n\n## 3. 결론\n\n도커 안의 두 컨테이너 사이의 통신을 하는 방법에 대해서 알아봤습니다. 결론적으로 네트워크상에 있는 컨테이너 아이피와 컨테이너 이름 두 가지의 방법으로 연결을 할 수 있었습니다. 저희는 이번에 두 가지를 모두 해 보고 후자의 방식을 추천해 드립니다. 왜냐하면 한 컨테이너는 여러 네트워크에 존재 할 수 있는데 네트워크마다 IP주소가 다르게 지정이 되기 때문입니다. 또한 컨테이너가 삭제되고 다시 실행되면 변경될 여지가 크기 때문입니다. 하지만 컨테이너 이름 같은 경우에는 프로그래머가 직접 지정할 수 있으니 좀 더 쉽게 관리할 수 있다고 생각됩니다.\n\n도커 공부를 조금 한 상태에서 트러블 슈팅하는 과정은 정말로 어려웠습니다. 앞으로 도커를 쓸 일이 많을 것 같으니, 공부를 좀 더 열심히 해야겠습니다.\n"},{"excerpt":"💬 개요 먼저 지속적 배포(CD, Continuous Deploy)를 구축하기 위해서 다음과 같은 기술을 선택했습니다. GitHub Self Hosted Runner : 현재 클라우드 상황에 적합하다. Docker Hub : EC2 내부에서 스프링 프로젝트가 빌드(build)된 이미지(Image)를 가져와 실행할 수 있다. image ✅ GitHub Se…","fields":{"slug":"/02.GitHub_Self_Hosted_Runner_Docker_Hub를_이용한_지속적_배포/"},"frontmatter":{"date":"July 31, 2023","title":"💿 지속적 배포(CD)를 GitHub Self Hosted Runner와 Docker Hub로 해보자","tags":["docker","github actions","self-hosted"]},"rawMarkdownBody":"\n## 💬 개요\n\n먼저 지속적 배포(CD, Continuous Deploy)를 구축하기 위해서 다음과 같은 기술을 선택했습니다.\n\n-   GitHub Self Hosted Runner : 현재 클라우드 상황에 적합하다.\n-   Docker Hub : EC2 내부에서 스프링 프로젝트가 빌드(build)된 이미지(Image)를 가져와 실행할 수 있다.\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/ae049740-d32f-4aac-9d4d-8c20ba042e11)\n\n<br>\n<br>\n<br>\n\n## **✅ GitHub Self Hosted Runner**를 선택한 이유\n\n현재 진행하고 있는 프로젝트의 클라우드 환경에 가장 적합하다고 느꼈다.\n\n사용하고 있는 EC2의 vpc 환경은 외부에서 내부로 들어올 수 있는 ip와 port가 제한된 상태였다.\n\n때문에 GitHub Actions의 워크플로우(workflow)를 이용하여 scp 명령어로 빌드된 jar를 전송하거나 AWS에 접근해서 스크립트를 직접 실행하는 것이 불가능했다.\n\n즉, EC2 내부에서 지속적 배포를 진행하기 위해서는 EC2 내부에서 외부로 접근하는 방식이 필요했다.\n\n이 때 사용해본 경험이 있는 도구는 두 가지였는데\n\n바로 Jenkins와 GitHub Self Hosted Runner 였고 나는 후자인 GitHub를 선택했다.\n\nJenkins에 비해 러닝 커브가 적고 GitHub와 연동이 잘되어 있어 문제 해결이 쉽기 때문이다.\n\nJenkins가 필요한 자원보다 GitHub Self Hosted Runner가 더 적다는 장점을 가지고 있다.\n\n또한 같은 프로젝트를 진행하고 있는 팀원들에게 GitHub를 설명하여 기술을 전파하는 것이 Jenkins 보다 더 쉽다는 것도 선택한 이유 중 하나다.\n\n<br>\n<br>\n<br>\n\n## **✅ 🐳 Docker Hub**를 선택한 이유\n\nAWS에서 EC2를 띄어 사용하고 있는 상태에서 스프링 프로젝트를 클론 받아 빌드하는 경우 EC2 메모리가 부족해질 수도 있다.\n\n이러한 위험성을 줄이기 위해서 미리 빌드된 jar 파일을 가져와서 실행시키도록 했다.\n\n하지만 현재 클라우드 환경은 빌드된 jar를 바로 가져올 수 없다.\n\nAWS에서 제공하는 S3와 같은 기술을 사용하지 않고 jar 파일을 다운받아 실행시켜야 했다.\n\n또한 저희는 하나의 EC2에서 React, Nginx, Spring을 같이 띄워 놓을거기 때문에 이후에 꼬이는 것을 방지하기 위해 환경을 독립적으로 가져갈 수 있었으면 했다.\n\n이러한 상황을 봤을 때 컨테이너로 환경을 제공해주면서 빌드된 이미지(image)를 풀(pull)받아 서버를 실행시킬 수 있는 도커(🐳 Docker)를 선택하기로 했다.\n\n> 기술이 정해졌고 대략적인 플로우도 나왔다.  \n> 🤔 그렇다면 이제 무슨 일을 해야 할까?\n\n이론적으로 현재 플로우에 대해 이해는 할 수 있었지만 실제로 기술을 사용해본적은 없기 때문에 먼저 기존 플로우를 다시 한 번 정리하면서 해야할 일을 체크리스트로 만들었다.\n\n💬 먼저 플로우를 정리해보자.\n\n-   GitHub Repository의 브랜치에 push 되었을 때 GitHub가 인지하고 스프링 프로젝트를 빌드(build)한다.\n-   빌드된 jar파일을 도커 이미지(Docker Image)로 만들어 도커 허브(Docker Hub)에 push한다.\n-   EC2에 띄운 GitHub Self Hosted Runner가 도커 허브가 업데이트 되었다는 것을 확인하고 도커 이미지를 자동으로 pull한다.\n-   EC2에 있는 도커 이미지를 컨테이너로 띄워 스프링 서버를 실행시킨다.\n\n플로우를 작성하고 흐름은 이해 되었다. 이제 체크리스트를 작성하면서 구체화 시켜보자.\n\n✔️ 체크리스트\n\n\\- 깃허브가 제공하는 클라우드 환경에서 할 일\n\n  - GitHub Repository 클론\n\n  - JDK 17 환경 설정\n\n  - Gradle Build\n\n  - Docker Buildx\n\n  - Docker Login\n\n  - Docker Image Build\n\n  - Docker Hub Push\n\n\\- EC2 내부에 있는 GitHub Self Hosted Runner가 할 일 \n\n  - Docker Login\n\n  - Docker Pull\n\n  - Docker Run\n\n이제 이 흐름을 따라가보자.\n\n<br>\n<br>\n<br>\n\n## 🟩 깃허브가 제공하는 클라우드 환경에서 할 일\n\n먼저 '**깃허브가 제공하는 클라우드 환경에서 할 일**'을 끝내보자.\n\n### 01\\. on: push : branches: \\[\"dev/BE\"\\]\n\nworkflow를 트리거(trigger)하기 위해서는 이벤트(event)를 발생시켜야 한다.\n\n현재 'dev/BE' 브랜치에 push 이벤트가 발생했을 때 workflow가 동작해야 한다.\n\n깃허브에서는 이러한 push 이벤트가 발생했을 때 workflow가 트리거할 수 있도록 설정하는 명령어를 문서에 정리해두었다.\n\n사용자 입장에서는 workflow에 다음과 같이 작성하면 된다.\n\n```\non:\n  push:\n    branches: [ \"dev/BE\" ]\n```\n\n [워크플로를 트리거하는 이벤트 - GitHub Docs](https://docs.github.com/ko/actions/using-workflows/events-that-trigger-workflows#push)\n\n<br>\n<br>\n\n### 02\\. jobs: build: runs-on: ubuntu-latest\n\nworkflow를 실행할 수 있는 환경을 러너(runner)라고 한다.\n\n그리고 workflow 내부에 작업(job)들을 진행하기 위해서는 운영체제와 같은 환경을 만들어줘야 한다.\n\nMacOS, Window 환경에서 작업을 진행할 수 있지만 EC2가 Linux로 띄어져있기 때문에 Ubuntu를 이용하기로 한다.\n\nworkflow에는 다음과 같이 작성하면 된다.\n\n```\njobs:\n  build:\n    runs-on: ubuntu-latest\n```\n\n [GitHub 호스팅 실행기 정보 - GitHub Docs](https://docs.github.com/ko/actions/using-github-hosted-runners/about-github-hosted-runners)\n\n<br>\n<br>\n\n### 03\\. uses: actions/checkout\n\nGitHub Actions를 사용해서 스프링 프로젝트를 빌드하려면 먼저 기본적인 파일을 클론받아야 한다.\n\n이 스텝을 하나의 액션(Action)으로 GitHub Marketplace에서 제공하고 있다.\n\nworkflow에는 다음과 같이 작성하면 된다.\n\n```\non:\n  push:\n    branches: [ \"dev/BE\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n\n# 위에 적힌 내용은 depth를 보여주기 위해 따로 분리하지 않았다.\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n```\n\n [Checkout - GitHub Marketplace](https://github.com/marketplace/actions/checkout)\n\n<br>\n<br>\n\n### 04\\. uses: actions/setup-java\n\nJDK 17를 사용하고 있는 스프링 프로젝트를 빌드하기 위해서 JDK를 설치하는 액션을 사용한다.\n\nworkflow에는 다음과 같이 작성하면 된다.\n\n```\n      - name: Set up JDK 17\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n          distribution: 'corretto'\n```\n\n [Setup Java JDK - GitHub Marketplace](https://github.com/marketplace/actions/setup-java-jdk)\n\n<br>\n<br>\n\n### 05\\. uses: gradle/gradle-build-action\n\nGradle로 스프링 프로젝트를 관리하고 있다. Gradle을 통해서 프로젝트를 빌드하려고 한다.\n\n workflow에는 다음과 같이 작성하면 된다.\n\n```\n      - name: Build with Gradle\n        uses: gradle/gradle-build-action@v2.6.0\n      - name: Execute Gradle build\n        run: |\n          cd backend/baton\n          ./gradlew build\n```\n\n [Gradle Build Action - GitHub Marketplace](https://github.com/marketplace/actions/gradle-build-action)\n\n<br>\n<br>\n\n### 06\\. uses: docker/login-action\n\nDocker Hub에 만든 이미지를 푸쉬하기 위해서 계정으로 로그인한다.\n\nDocker에 로그인하고 계정에서 토큰을 만들어야 접근이 가능하다.\n\n아래는 아직 토큰을 만들지 않은 상태의 페이지다.\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/b5684ce0-98a7-4a58-af17-8f7829338707)\n\n토큰을 만들어서 GitHub Secret에 등록해서 workflow에서 사용하도록 설정했다.\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/42caa09a-f2b3-4e0d-b778-b760d999555d)\n\n참고로  workflow에서 secret을 사용하기 위해서는 \\`${{ secrets.이름 }}\\`와 같은 형식으로 작성하면 된다.\n\nworkflow에는 다음과 같이 작성하면 된다.\n\n```\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2.2.0\n        with:\n          username: ${{ secrets.DOCKERHUB_DEV_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_DEV_TOKEN }}\n```\n\n [Docker Hub Container Image Library](https://hub.docker.com/)\n\n [Docker Login - GitHub Marketplace](https://github.com/marketplace/actions/docker-login)\n\n<br>\n<br>\n\n### 07\\. run: docker build\n\nDocker Image를 만들기 위해서 docker build 명령어를 작성한다.\n\n프로젝트 최상단 패키지에 만들어 놓은 Dockerfile을 실행할 수 있도록 명시했다.\n\nDockerfile 내용은 다음과 같다.  \nEC2 환경은 arm64v8이다.\n\nJDK는 Corretto 17을 이용했다.\n\njar를 복사고 스프링 프로필 환경 변수를 dev로 두고 스프링 서버를 실행시킨다.\n\n```\nFROM arm64v8/amazoncorretto:17\n\nWORKDIR /app\n\nCOPY ./build/libs/baton-0.0.1-SNAPSHOT.jar /app/baton.jar\n\nCMD [\"java\", \"-jar\", \"-Dspring.profiles.active=dev\", \"baton.jar\"]\n```\n\nworkflow에는 다음과 같이 작성하면 된다.\n\n```\n      - name: Docker Image Build\n        run: |\n          cd backend/baton\n          docker build --platform linux/arm64/v8 -t 2023baton/2023baton -f Dockerfile-dev .\n```\n\n### 08\\. run: docker push\n\n이제 이미지로 만든 스프링 프로젝트를 Docker Hub에 push하자.\n\n먼저 Docker에서 Repository를 만들자.\n\nworkflow에 \\`docker push 2023baton/2023baton\\` 이라는 명령어가 명시되어 있는데\n\n\\`docker push {docker\\_username}/{docker\\_repository\\_name}\\` 형태로 명시하면 된다.\n\nworkflow에는 다음과 같이 작성하면 된다.\n\n```\n      - name: Docker Hub Push\n        run: docker push 2023baton/2023baton\n```\n\n### 09\\. \\`**깃허브가 제공하는 클라우드 환경에서 할 일\\`** workflow 종합\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/5140c7d1-362d-4ac7-a106-abd3dc646f65)\n\n01 ~ 08 까지 소개한 스텝들을 합쳐 하나의 워크플로우를 작성하면 아래와 같다.\n\n```\non:\n  push:\n    branches: [ \"dev/BE\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n          distribution: 'corretto'\n\n      - name: Build with Gradle\n        uses: gradle/gradle-build-action@v2.6.0\n      - name: Execute Gradle build\n        run: |\n          cd backend/baton\n          ./gradlew build\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2.2.0\n        with:\n          username: ${{ secrets.DOCKERHUB_DEV_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_DEV_TOKEN }}\n\n      - name: Docker Image Build\n        run: |\n          cd backend/baton\n          docker build --platform linux/arm64/v8 -t 2023baton/2023baton -f Dockerfile-dev .\n\n      - name: Docker Hub Push\n        run: docker push 2023baton/2023baton\n```\n\n<br>\n<br>\n<br>\n\n## 🟩 EC2 내부에 있는 GitHub Self Hosted Runner가 할 일\n\n이제 Docker Hub에 스프링 이미지까지 올라가 있다.\n\nEC2에 있는 GitHub Self Hosted Runner가 Docker Hub에 이미지를 pull해서 컨테이너를 실행하도록 workflow를 작성하자.\n\n### 01\\. GitHub Self Hosted Runner 설치\n\nRepository의 Settinggs에 들어가 Actions 탭에 Runners를 들어가서 \\`New self-hosted runner\\` 버튼을 누르면 명령어를 보여준다.\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/d29a74d2-cd05-482d-9570-8daff8d0e414)\n\n다음과 같이 Runner Image를 고를 수 있고 다운로드, 설정, 실행 등 의 정보를 전부 제공해주기 때문에 EC2에 명령어를 실행하면 끝이다.\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/9f8cdb9e-0b19-4027-bf66-4ee4350e3bd9)\n\n### 02\\. runs-on: \\[self-hosted\\]\n\nEC2에 GitHub Self Hosted Runner를 설치했다면 workflow를 작성해주자.\n\n\\`self-hosted\\`라고 작성하면 우리가 방금 만든 runner를 선택하게 된다.\n\n만약 다음과 같이 Self-Hosted Runner가 두 개 이상이라면 라벨(label)을 넣어서 구분할 수 있다.\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/d18331d0-15bf-4b3c-ac19-817065076ac7)\n\n다음과 같은 상황에서 나는 deploy 환경에서는 deploy라는 라벨을 붙였다.\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/b5340890-b187-44d1-bc0a-c9a86e08e93b)\n\nrunner가 1개 일 때는 workflow는 다음과 같이 작성할 수 있다.\n\n```\njobs:\n  dev-deploy:\n    runs-on: self-hosted\n```\n\nrunner가 2개 이상일 때는 구분지을 수 있어야 되기 때문에 아래와 같이 라벨까지 명시해주면 된다.\n\n```\n# Self-Hosted Runner : dev\njobs:\n  dev-deploy:\n    runs-on: [self-hosted, Linux, ARM64]\n```\n\n```\n# Self-Hosted Runner : deploy \njobs:\n  dev-deploy:\n    runs-on: [self-hosted, Linux, ARM64, deploy]\n```\n\n현재 워크플로우에서 사용하는 Self-Hosted Runner는 dev라는 것을 생각해줬으면 좋겠다.\n\n### 03\\. needs: build\n\n이전에 Docker Hub에 이미지를 push하는 작업이 있었다.\n\n그리고 지금 작성하고 있는 작업은 EC2에서 Docker Hub 이미지를 pull 받아 컨테이너를 실행시키는 것이다.\n\n이 때 순서를 정해주지 않으면 업데이트 되지 않은 이미지를 받아 컨테이너를 실행시킬 수 도 있다.\n\n그러한 문제를 해결하기 위해서 needs라는 키워드를 달아 build라는 작업이 끝나면 다음 작업이 진행되도록 만들자.\n\nworkflow에는 다음과 같이 작성하면 된다.\n\n```\non:\n  push:\n    branches: [ \"dev/BE\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n  deploy:\n    runs-on: [self-hosted, Linux, ARM64]\n    needs: build\n```\n\n### 04\\. docker pull\n\n이제 Docker Hub에 로그인하여 이미지를 pull하도록 하자.\n\nDocker Hub에 2023baton 레포지터리에서 2023baton 이미지를  pull한다.\n\nworkflow는 다음과 같이 작성하면 된다.\n\n```\n    steps:\n      - name: Pull Latest Docker Image\n        run: |\n          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}\n          sudo docker pull 2023baton/2023baton:latest\n```\n\n### 05\\. docker run\n\nDocker Image가 pull 받아 최신 상태가 된 경우 스프링 Container를 멈추고 삭제한다.\n\n그리고 다시 새로운 Container를 띄우도록 한다.\n\nworkflow는 다음과 같이 작성하면 된다.\n\n```\n    steps:\n      - name: Pull Latest Docker Image\n        run: |\n          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}\n          if sudo docker inspect spring-baton &>/dev/null; then\n            sudo docker stop spring-baton\n            sudo docker rm -f spring-baton\n          fi\n          sudo docker pull 2023baton/2023baton:latest\n\n      - name: Docker Run\n        run: |\n          sudo docker run --name spring-baton -p 8080:8080 2023baton/2023baton:latest 1>> build.log 2>> error.log &name: dev/BE CD on Push\n```\n\n#### 06\\. \\`**EC2 내부에 있는 GitHub Self Hosted Runner가 할 일**\\` worflow 종합\n\n![image](https://github.com/2023-baton/2023-baton.github.io/assets/82203978/675fcde0-5e8e-4bab-aca5-d47a262329f4)\n\n```\n  deploy:\n    runs-on: [self-hosted, Linux, ARM64]\n    needs: build\n\n    steps:\n      - name: Pull Latest Docker Image\n        run: |\n          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}\n          if sudo docker inspect spring-baton &>/dev/null; then\n            sudo docker stop spring-baton\n            sudo docker rm -f spring-baton\n          fi\n          sudo docker pull 2023baton/2023baton:latest\n\n      - name: Docker Run\n        run: |\n          sudo docker run --name spring-baton -p 8080:8080 2023baton/2023baton:latest 1>> build.log 2>> error.log &\n```\n\n<br>\n<br>\n<br>\n\n## 🟩 최종 워크플로우\n\n```\nname: dev/BE CD on Push\n\non:\n  push:\n    branches: [ \"dev/BE\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n        with:\n          token: ${{ secrets.SUBMODULE_BE_TOKEN }}\n          submodules: recursive\n\n      - name: Set up JDK 17\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n          distribution: 'corretto'\n\n      - name: Build with Gradle\n        uses: gradle/gradle-build-action@v2.6.0\n      - name: Execute Gradle build\n        run: |\n          cd backend/baton\n          ./gradlew build\n\n      - name: Login to Docker Hub\n        uses: docker/login-action@v2.2.0\n        with:\n          username: ${{ secrets.DOCKERHUB_DEV_USERNAME }}\n          password: ${{ secrets.DOCKERHUB_DEV_TOKEN }}\n\n      - name: Docker Image Build\n        run: |\n          cd backend/baton\n          docker build --platform linux/arm64/v8 -t 2023baton/2023baton -f Dockerfile-dev .\n\n      - name: Docker Hub Push\n        run: docker push 2023baton/2023baton\n\n  deploy:\n    runs-on: [self-hosted, Linux, ARM64]\n    needs: build\n\n    steps:\n      - name: Pull Latest Docker Image\n        run: |\n          sudo docker login --username ${{ secrets.DOCKERHUB_DEV_USERNAME }} --password ${{ secrets.DOCKERHUB_DEV_TOKEN }}\n          if sudo docker inspect spring-baton &>/dev/null; then\n            sudo docker stop spring-baton\n            sudo docker rm -f spring-baton\n          fi\n          sudo docker pull 2023baton/2023baton:latest\n\n      - name: Docker Compose\n        run: |\n          sudo docker run --name spring-baton -p 8080:8080 2023baton/2023baton:latest 1>> build.log 2>> error.log &\n```\n\n이제 브랜치에 push 할 때 마다 새로운 이미지가 Docker Hub에 push 되고 Self-hosted는 pull 받아 새로운 컨테이너를 띄운다.\n"},{"excerpt":"안녕하세요 이번에 바톤 프로젝트를 기초 세팅하는 시간을 가졌는데요. 그 중 docker로 DB를 관리하는 부분이 기억에 남아 글로 기록해보려합니다. docker로 DB를 관리하게 된 이유 1. 일관된 환경 도커 이미지를 사용하면 개발, 로컬, 운영 환경에서 모두 동일한 이미지를 배포할 수 있습니다.\n즉, 모든 데이터베이스의 환경을 동일하게 유지할 수 있고…","fields":{"slug":"/first/"},"frontmatter":{"date":"July 20, 2023","title":"🐳 도커로 DB 관리하기","tags":["docker","database"]},"rawMarkdownBody":"\n안녕하세요 이번에 바톤 프로젝트를 기초 세팅하는 시간을 가졌는데요. 그 중 docker로 DB를 관리하는 부분이 기억에 남아 글로 기록해보려합니다.\n\n## docker로 DB를 관리하게 된 이유\n### 1. 일관된 환경\n도커 이미지를 사용하면 개발, 로컬, 운영 환경에서 모두 동일한 이미지를 배포할 수 있습니다.\n즉, 모든 데이터베이스의 환경을 동일하게 유지할 수 있고 환경 변화가 있다면 동일하게 환경을 변경시킬 수 있습니다.\n\n또한 도커 컴포즈를 이용하여 로컬에서도 동료들간 같은 환경을 구성하여 DB를 사용할 수 있습니다.\n\n### 2. 환경 충돌 방지\n우아한테크코스에서 DB를 위한 ec2 인스턴스는 1개만 제공되었습니다.\n나중에 mysql 뿐만 아니라 다른 db를 추가하게 되는 경우에 인스턴스 내부에서 환경이 얽힐수도 있겠다는 생각을 했습니다.\n만약 도커를 이용하여 컨테이너를 분리하게 된다면 환경이 얽힐 일이 없고, 더 안정적인 운영이 가능하다고 생각했습니다.\n\n### 3. 손쉬운 스케일링\n서비스가 커지게되면 트래픽이 늘어나고 부하가 발생할 수 있는데요.\n이때 도커를 이용하면 컨테이너를 필요한 시점에 빠르게 확장하거나 축소할 수 있습니다.\n\n</br>\n\n## EC2에 도커 설치\n```bash\nsudo snap install docker\n```\n명령어를 이용하여 도커를 설치합니다.\n\n처음에는 `apt update`와 `apt install` 명령어를 통해 도커를 설치하려 했는데, 잘 되지 않았습니다.\n찾아보니 요즘은 `snap`을 사용하면 더 간단히 도커를 설치할 수 있기에 `snap` 사용을 권장한다고 하네요.\n![](https://velog.velcdn.com/images/hooni_/post/25198967-049d-4723-9a59-c0b4ca7e5857/image.png)\n\n위와 같이 설치를 완료했습니다.\n![](https://velog.velcdn.com/images/hooni_/post/6dcd0c64-4f45-491f-b172-b850c0a0febb/image.png)\n\n저는 매번 `sudo`를 이용하여 권한 인증하는 것이 귀찮아서 추가적인 설정을 통해 일반 사용자도 도커에 접근할 수 있도록 설정했습니다.\n과정은 [해당 링크](https://snapcraft.io/docker)를 참고했습니다.\n\n```bash\n sudo addgroup --system docker\n sudo adduser $USER docker\n newgrp docker\n sudo snap disable docker\n sudo snap enable docker\n```\n\n### before\n![](https://velog.velcdn.com/images/hooni_/post/103f8395-0ee3-4eb8-935d-5fc165ae413c/image.png)\n### after\n![](https://velog.velcdn.com/images/hooni_/post/f1634b4b-120e-4808-943c-34a901dedf99/image.png)\n\n\n</br>\n\n## 도커에 mysql 컨테이너 설치\n\n### 이미지 다운\n\n도커에서 mysql 이미지를 다운받습니다.\n```bash\ndocker pull mysql\n```\n도커에서 **이미지**란 하나의 환경파일(?)을 말합니다. nginx, mysql, node 등등 많은 이미지들이 있는데, 사용 목적에 맞게 이미지를 선택해서 컨테이너로 생성하면 해당 이미지에 맞는 환경이 설치된 상태로 컨테이너를 사용할 수 있습니다.\nOOP에서 원하는 클래스의 인스턴스를 생성하는 것과 비슷한 느낌이라고 할 수 있겠습니다.\n\n![](https://velog.velcdn.com/images/hooni_/post/9994784b-ed69-470b-8d09-e0323d42bc15/image.png)\n\nmysql 이미지가 정상적으로 깔린 것을 확인할 수 있습니다.\n`tag`는 버전을 뜻하는데, latest는 가장 최신버전이라는 뜻입니다. 만약 제가 `docker pull mysql:8.0.33` 명령어로 이미지를 풀 받게 되면 해당 버전의 mysql을 풀 받습니다.\n\n![](https://velog.velcdn.com/images/hooni_/post/1dae895b-e8e4-48f4-88b1-19527ffb205e/image.png)\n\n현재 가장 최근 버전의 mysql이 8.0.33 이어서 image id가 같은 것 같습니다.\n\n### 컨테이너 생성 & 실행\n```bash\ndocker run --name mysql-dev-container -e MYSQL_ROOT_PASSWORD={비밀번호} -d -p 3306:3306 mysql:latest\n```\n\n해석하자면, \n- `--name`: `mysql-dev-container`의 이름으로 컨테이너를 실행한다.\n- `-e`: 컨테이너의 환경 변수중 `MYSQL_ROOT_PASSWORD`를 입력한 비밀번호로 설정한다.\n- `-d`: 데몬 모드로 실행한다. (백그라운드 모드)\n- `-p`: 호스트 포트:컨테이너 포트로 설정한다.\n- 이미지는 `mysql:latest` 로 설정한다.\n\n![](https://velog.velcdn.com/images/hooni_/post/f3d174f9-732d-49c7-befb-1bc570d1e138/image.png)\n\n정상적으로 컨테이너가 생긴 것을 확인할 수 있습니다.\n\n이제 컨테이너에 접속해보겠습니다.\n```bash\ndocker exec -it {컨테이너 Id} bash\n```\n\n위 명령어를 통해 도커 컨테이너 bash에 접속했습니다.\n\n### mysql에 db 생성\n이제 컨테이너에 mysql database를 설치해보도록 하겠습니다.\n여기부터는 일반 리눅스나 맥에서 database 생성하는 것과 똑같습니다.\n\n먼저 mysql에 접속합니다.\n```bash\nmysql -u root -p\n```\n그리고, database를 생성합니다.\n```bash\ncreate database ditoo_dev;\n```\n\nintellij에서 생성한 db에 정상적으로 접근되는지 확인해보겠습니다!\n![](https://velog.velcdn.com/images/hooni_/post/92c5d4df-6651-44da-aa40-dea62909261e/image.png)\n정상적으로 접근되었습니다.\n\n간단한 post, tag, post_tag 테이블을 만들어 table이 정상적으로 생성되는지 확인해보도록 하겠습니다.\n\n![](https://velog.velcdn.com/images/hooni_/post/cb75119b-fa86-476b-9b26-bcf9001e992d/image.png)\n\n스프링 어플리케이션에서는 정상적으로 테이블이 생성된 것을 확인했습니다.\n\n![](https://velog.velcdn.com/images/hooni_/post/19117d25-f71e-4d01-b1fb-65e754bf582a/image.png)\n\ndb에도 정상적으로 table이 생긴 것을 확인할 수 있었습니다.\n\n</br>\n\n## 마치며\n\ndocker로 간단하게 db를 관리하는 것을 학습했습니다.\n다음 시간에는 docker-compose를 이용하여 db, spring, react 모두 같이 관리하는 방법에 대해 학습해보려 합니다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}